// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package gensql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addReviewer = `-- name: AddReviewer :one
insert into reviewers_to_pull_requests (user_id, pull_req_id)
values ($1, $2)
returning user_id
`

type AddReviewerParams struct {
	UserID    string
	PullReqID string
}

func (q *Queries) AddReviewer(ctx context.Context, arg AddReviewerParams) (string, error) {
	row := q.db.QueryRow(ctx, addReviewer, arg.UserID, arg.PullReqID)
	var user_id string
	err := row.Scan(&user_id)
	return user_id, err
}

const checkPRExists = `-- name: CheckPRExists :one
select exists(select 1 from pull_requests where pull_req_id = $1) as exists
`

func (q *Queries) CheckPRExists(ctx context.Context, pullReqID string) (bool, error) {
	row := q.db.QueryRow(ctx, checkPRExists, pullReqID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkTeamExists = `-- name: CheckTeamExists :one
select exists(select 1 from teams where team_name = $1) as exists
`

func (q *Queries) CheckTeamExists(ctx context.Context, teamName string) (bool, error) {
	row := q.db.QueryRow(ctx, checkTeamExists, teamName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserExists = `-- name: CheckUserExists :one
select exists(select 1 from users where user_id = $1) as exists
`

func (q *Queries) CheckUserExists(ctx context.Context, userID string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExists, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countReviewersForPR = `-- name: CountReviewersForPR :one
select count(*) as reviewer_count
from reviewers_to_pull_requests
where pull_req_id = $1
`

func (q *Queries) CountReviewersForPR(ctx context.Context, pullReqID string) (int64, error) {
	row := q.db.QueryRow(ctx, countReviewersForPR, pullReqID)
	var reviewer_count int64
	err := row.Scan(&reviewer_count)
	return reviewer_count, err
}

const createPR = `-- name: CreatePR :one
insert into pull_requests (pull_req_id, pull_req_name, author_id)
values ($1, $2, $3)
returning pull_req_id, pull_req_name, author_id, pull_req_status, created_at, merged_at
`

type CreatePRParams struct {
	PullReqID   string
	PullReqName string
	AuthorID    string
}

func (q *Queries) CreatePR(ctx context.Context, arg CreatePRParams) (PullRequest, error) {
	row := q.db.QueryRow(ctx, createPR, arg.PullReqID, arg.PullReqName, arg.AuthorID)
	var i PullRequest
	err := row.Scan(
		&i.PullReqID,
		&i.PullReqName,
		&i.AuthorID,
		&i.PullReqStatus,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
insert into teams (team_name) 
values ($1)
returning team_name
`

func (q *Queries) CreateTeam(ctx context.Context, teamName string) (string, error) {
	row := q.db.QueryRow(ctx, createTeam, teamName)
	var team_name string
	err := row.Scan(&team_name)
	return team_name, err
}

const getActiveTeammates = `-- name: GetActiveTeammates :many
select utt.user_id 
from users_to_teams utt
inner join users u on u.user_id = utt.user_id
where utt.team_name = $1
  and u.is_active = true
  and u.user_id <> all($2::text[])
`

type GetActiveTeammatesParams struct {
	TeamName string
	Column2  []string
}

func (q *Queries) GetActiveTeammates(ctx context.Context, arg GetActiveTeammatesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getActiveTeammates, arg.TeamName, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPR = `-- name: GetPR :one
select pull_req_id, pull_req_name, author_id, pull_req_status, created_at, merged_at from pull_requests
where pull_req_id = $1
`

func (q *Queries) GetPR(ctx context.Context, pullReqID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPR, pullReqID)
	var i PullRequest
	err := row.Scan(
		&i.PullReqID,
		&i.PullReqName,
		&i.AuthorID,
		&i.PullReqStatus,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const getPRsReviewedByUser = `-- name: GetPRsReviewedByUser :many
select prq.pull_req_id, prq.pull_req_name, prq.author_id, prq.pull_req_status
from pull_requests prq
inner join reviewers_to_pull_requests rtp on rtp.pull_req_id = prq.pull_req_id
where rtp.user_id = $1
`

type GetPRsReviewedByUserRow struct {
	PullReqID     string
	PullReqName   string
	AuthorID      string
	PullReqStatus Prstat
}

func (q *Queries) GetPRsReviewedByUser(ctx context.Context, userID string) ([]GetPRsReviewedByUserRow, error) {
	rows, err := q.db.Query(ctx, getPRsReviewedByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPRsReviewedByUserRow
	for rows.Next() {
		var i GetPRsReviewedByUserRow
		if err := rows.Scan(
			&i.PullReqID,
			&i.PullReqName,
			&i.AuthorID,
			&i.PullReqStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPRwithReviewers = `-- name: GetPRwithReviewers :one
select 
    pr.pull_req_id,
    pr.pull_req_name,
    pr.author_id,
    pr.pull_req_status,
    pr.created_at,
    pr.merged_at,
    coalesce(
        array_agg(rtp.user_id) filter (where rtp.user_id is not null),
        array[]::text[]
    ) as assigned_reviewers
from pull_requests pr
left join reviewers_to_pull_requests rtp on pr.pull_req_id = rtp.pull_req_id
where pr.pull_req_id = $1
group by pr.pull_req_id, pr.pull_req_name, pr.author_id, pr.pull_req_status, pr.created_at, pr.merged_at
`

type GetPRwithReviewersRow struct {
	PullReqID         string
	PullReqName       string
	AuthorID          string
	PullReqStatus     Prstat
	CreatedAt         pgtype.Timestamp
	MergedAt          pgtype.Timestamp
	AssignedReviewers interface{}
}

func (q *Queries) GetPRwithReviewers(ctx context.Context, pullReqID string) (GetPRwithReviewersRow, error) {
	row := q.db.QueryRow(ctx, getPRwithReviewers, pullReqID)
	var i GetPRwithReviewersRow
	err := row.Scan(
		&i.PullReqID,
		&i.PullReqName,
		&i.AuthorID,
		&i.PullReqStatus,
		&i.CreatedAt,
		&i.MergedAt,
		&i.AssignedReviewers,
	)
	return i, err
}

const getReviewersForPR = `-- name: GetReviewersForPR :many
select user_id
from reviewers_to_pull_requests
where pull_req_id = $1
`

func (q *Queries) GetReviewersForPR(ctx context.Context, pullReqID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getReviewersForPR, pullReqID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeam = `-- name: GetTeam :one
select team_name from teams 
where team_name = $1
`

func (q *Queries) GetTeam(ctx context.Context, teamName string) (string, error) {
	row := q.db.QueryRow(ctx, getTeam, teamName)
	var team_name string
	err := row.Scan(&team_name)
	return team_name, err
}

const getUserCoworkers = `-- name: GetUserCoworkers :many
select utt.user_id 
from users_to_teams utt
inner join users_to_teams uttf on utt.team_name = uttf.team_name
where uttf.user_id = $1 
  and utt.user_id <> $1
`

func (q *Queries) GetUserCoworkers(ctx context.Context, userID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserCoworkers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTeam = `-- name: GetUserTeam :one
select team_name
from users_to_teams
where user_id = $1
`

func (q *Queries) GetUserTeam(ctx context.Context, userID string) (string, error) {
	row := q.db.QueryRow(ctx, getUserTeam, userID)
	var team_name string
	err := row.Scan(&team_name)
	return team_name, err
}

const getUserWithTeam = `-- name: GetUserWithTeam :one
select u.user_id, u.user_name, u.is_active, ut.team_name
from users u
left join users_to_teams ut using (user_id)
where u.user_id = $1
`

type GetUserWithTeamRow struct {
	UserID   string
	UserName string
	IsActive bool
	TeamName pgtype.Text
}

func (q *Queries) GetUserWithTeam(ctx context.Context, userID string) (GetUserWithTeamRow, error) {
	row := q.db.QueryRow(ctx, getUserWithTeam, userID)
	var i GetUserWithTeamRow
	err := row.Scan(
		&i.UserID,
		&i.UserName,
		&i.IsActive,
		&i.TeamName,
	)
	return i, err
}

const getUsersForTeam = `-- name: GetUsersForTeam :many
select u.user_id, u.user_name, u.is_active
from users_to_teams ut
inner join users u using (user_id)
where ut.team_name = $1
`

func (q *Queries) GetUsersForTeam(ctx context.Context, teamName string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersForTeam, teamName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.UserID, &i.UserName, &i.IsActive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isReviewerAssigned = `-- name: IsReviewerAssigned :one
select exists(
    select 1 from reviewers_to_pull_requests
    where pull_req_id = $1 and user_id = $2
) as is_assigned
`

type IsReviewerAssignedParams struct {
	PullReqID string
	UserID    string
}

func (q *Queries) IsReviewerAssigned(ctx context.Context, arg IsReviewerAssignedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isReviewerAssigned, arg.PullReqID, arg.UserID)
	var is_assigned bool
	err := row.Scan(&is_assigned)
	return is_assigned, err
}

const mergePR = `-- name: MergePR :one
update pull_requests
set pull_req_status = 'merged'::prstat
where pull_req_id = $1
returning pull_req_id, pull_req_name, author_id, pull_req_status, created_at, merged_at
`

func (q *Queries) MergePR(ctx context.Context, pullReqID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, mergePR, pullReqID)
	var i PullRequest
	err := row.Scan(
		&i.PullReqID,
		&i.PullReqName,
		&i.AuthorID,
		&i.PullReqStatus,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const removeReviewer = `-- name: RemoveReviewer :exec
delete from reviewers_to_pull_requests
where pull_req_id = $1 and user_id = $2
`

type RemoveReviewerParams struct {
	PullReqID string
	UserID    string
}

func (q *Queries) RemoveReviewer(ctx context.Context, arg RemoveReviewerParams) error {
	_, err := q.db.Exec(ctx, removeReviewer, arg.PullReqID, arg.UserID)
	return err
}

const userSetIsActive = `-- name: UserSetIsActive :one
update users
set is_active = $2
where user_id = $1
returning user_id, user_name, is_active
`

type UserSetIsActiveParams struct {
	UserID   string
	IsActive bool
}

func (q *Queries) UserSetIsActive(ctx context.Context, arg UserSetIsActiveParams) (User, error) {
	row := q.db.QueryRow(ctx, userSetIsActive, arg.UserID, arg.IsActive)
	var i User
	err := row.Scan(&i.UserID, &i.UserName, &i.IsActive)
	return i, err
}
